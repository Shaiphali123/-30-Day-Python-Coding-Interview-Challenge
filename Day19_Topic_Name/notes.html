<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 19: Python Dictionary Use Cases</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 20px auto;
            padding: 0 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #1a1a1a;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }
        h1 { font-size: 2.2em; }
        h2 { font-size: 1.8em; }
        h3 { font-size: 1.4em; }
        code {
            background-color: #eef;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.95em;
        }
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        strong {
            color: #0056b3;
        }
        .container {
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        hr {
            border: 0;
            height: 1px;
            background-color: #ddd;
            margin: 40px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üóìÔ∏è Day 19: Python Dictionary Use Cases</h1>
        <p>Dictionaries are one of Python's most powerful and versatile data structures. Their key-value pair system allows for flexible and efficient solutions to many common programming problems. Let's explore some key use cases.</p>

        <hr>

        <h2>1. Representing Structured Data (like JSON)</h2>
        <p>Dictionaries are perfect for modeling real-world objects or structured data, much like JSON objects in web development. Each key represents an attribute, and the value is the data for that attribute.</p>
        
        <h3>Example: User Profile</h3>
        <pre><code>
# A dictionary representing a user's profile
user_profile = {
    "user_id": 101,
    "username": "alex_coder",
    "email": "alex@example.com",
    "is_active": True,
    "permissions": ["read", "write"]
}

# Accessing data is intuitive
print(f"Username: {user_profile['username']}")
print(f"Permissions: {user_profile['permissions'][0]}")
        </code></pre>
        <p>This is much more readable and manageable than using lists or tuples, where you'd have to remember the index of each piece of data.</p>
        
        <hr>

        <h2>2. Frequency Counting üìä</h2>
        <p>A classic use case for dictionaries is to count the occurrences of items in a sequence. The item becomes the key, and its count becomes the value.</p>

        <h3>Example: Counting Characters in a String</h3>
        <pre><code>
text = "hello world"
char_counts = {}

for char in text:
    # Use .get() to handle the first time a character is seen
    char_counts[char] = char_counts.get(char, 0) + 1

print(char_counts)
# Output: {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1}
        </code></pre>
        <p><strong>Pro Tip:</strong> For this specific task, Python's standard library provides a specialized dictionary subclass: <code>collections.Counter</code>.</p>
        <pre><code>
from collections import Counter

text = "hello world"
char_counts = Counter(text)
print(char_counts)
# Output: Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1})
        </code></pre>

        <hr>

        <h2>3. Caching / Memoization ‚ö°</h2>
        <p>Dictionaries can act as a cache to store the results of expensive computations. This technique, called <strong>memoization</strong>, prevents re-calculating results for the same inputs, dramatically improving performance.</p>

        <h3>Example: Fibonacci Sequence</h3>
        <pre><code>
# A cache to store previously computed Fibonacci numbers
fib_cache = {}

def fibonacci(n):
    # If the value is in the cache, return it
    if n in fib_cache:
        return fib_cache[n]
    
    # Base cases
    if n <= 1:
        return n
        
    # Compute it, store it in the cache, and then return it
    result = fibonacci(n - 1) + fibonacci(n - 2)
    fib_cache[n] = result
    return result

# The calculation for 35 would be very slow without memoization
print(f"Fibonacci(35) = {fibonacci(35)}")
print(f"Cache content (partial): {{... '35': {fib_cache[35]}}}")
        </code></pre>

        <hr>

        <h2>4. Grouping Data üìÇ</h2>
        <p>You can use a dictionary to group items from a list based on a common property. The property becomes the key, and the value is a list of all items sharing that property.</p>

        <h3>Example: Grouping Students by Grade</h3>
        <pre><code>
students = [
    {"name": "Alice", "grade": "A"},
    {"name": "Bob", "grade": "B"},
    {"name": "Charlie", "grade": "A"},
    {"name": "David", "grade": "C"},
    {"name": "Eve", "grade": "B"},
]

grades = {}
for student in students:
    grade = student["grade"]
    # .setdefault() initializes the key with an empty list if it's not present
    grades.setdefault(grade, []).append(student["name"])

print(grades)
# Output: {'A': ['Alice', 'Charlie'], 'B': ['Bob', 'Eve'], 'C': ['David']}
        </code></pre>
        
        <hr>

        <h1>üé§ Interview Questions and Answers</h1>
        
        <h3>Q1: You are given two dictionaries. How do you merge them into a single dictionary?</h3>
        <p><strong>Answer:</strong> There are two common ways. The <code>update()</code> method modifies one dictionary in place, while the dictionary unpacking syntax (<code>**</code>) creates a new dictionary. If there are overlapping keys, the value from the second dictionary will overwrite the first.</p>
        <pre><code>
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}

# Method 1: Using update()
merged_dict1 = dict1.copy() # Use copy to avoid modifying the original
merged_dict1.update(dict2)
print(f"Using update(): {merged_dict1}") # {'a': 1, 'b': 3, 'c': 4}

# Method 2: Using dictionary unpacking (Python 3.5+)
merged_dict2 = {**dict1, **dict2}
print(f"Using unpacking: {merged_dict2}") # {'a': 1, 'b': 3, 'c': 4}
        </code></pre>

        <h3>Q2: What is the difference between accessing a value with <code>d[key]</code> and <code>d.get(key)</code>?</h3>
        <p><strong>Answer:</strong> The key difference is in error handling.</p>
        <ul>
            <li><code>d[key]</code> (bracket notation): This directly accesses the key. If the key does not exist, it raises a <strong><code>KeyError</code></strong>.</li>
            <li><code>d.get(key, default=None)</code>: This method attempts to get the key. If the key doesn't exist, it returns a default value (which is <code>None</code> if not specified) instead of raising an error.</li>
        </ul>
        <p>You should use <code>d.get()</code> when you are not sure if a key exists and you want to handle its absence gracefully without a <code>try...except</code> block.</p>
        <pre><code>
d = {'a': 100}

# Using bracket notation
print(d['a']) # Works fine, prints 100
# print(d['b']) # Would raise a KeyError

# Using .get()
print(d.get('a'))       # Prints 100
print(d.get('b'))       # Prints None (default value)
print(d.get('b', 0))    # Prints 0 (specified default)
        </code></pre>

        <h3>Q3: How would you find the key corresponding to the maximum value in a dictionary?</h3>
        <p><strong>Answer:</strong> You can use the <code>max()</code> function with a custom <code>key</code> argument. The key argument should be a function that tells <code>max()</code> what to compare. In this case, we tell it to compare the dictionary's values by using <code>d.get</code>.</p>
        <pre><code>
scores = {'math': 95, 'science': 98, 'history': 88}

# The key=scores.get tells max() to look at the values, not the keys
top_subject = max(scores, key=scores.get)

print(f"The subject with the highest score is: {top_subject}")
# Output: The subject with the highest score is: science
        </code></pre>
    </div>
</body>
</html>
